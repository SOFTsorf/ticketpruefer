<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DFI Realism</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Doto:wght,ROND@900,100&family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --led: #ffaa00;         /* Hauptfarbe Orange */
            --led-dim: #995500;     /* Gedimmte Farbe für Linien */
            --led-alert: #ff3333;   /* Rot für Ausfälle */
            --bg: #0d0d0d;          /* Fast Schwarz für Hintergrund */
            --grid-color: #000;     /* Farbe des Gitters zwischen LEDs */
            
            --col-line: 18vw; 
            --col-time: 25vw;
        }

        body, html {
            margin: 0; padding: 0;
            background: var(--bg);
            color: var(--led);
            font-family: 'Doto', sans-serif;
            font-variation-settings: "ROND" 100; /* Eckige Pixel */
            overflow: hidden;
            width: 100vw; height: 100vh;
            cursor: none; /* Maus verstecken für Kiosk-Feeling */
        }

        /* --- SUB-PIXEL STRUKTUR (Das Raster) --- */
        body::after {
            content: " ";
            position: fixed; inset: 0; z-index: 9999;
            /* Ein feines Punkt-Raster simulieren */
            background-image: 
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px),
                linear-gradient(var(--grid-color) 1px, transparent 1px);
            background-size: 4px 4px; /* Größe der einzelnen "LEDs" */
            background-color: rgba(0,0,0,0.1);
            pointer-events: none; /* Klicks gehen durch */
        }

        /* --- LED GLOW EFFEKT --- */
        #display-screen {
            text-shadow: 0 0 4px rgba(255, 170, 0, 0.4); /* Leichter Schein */
        }

        /* SETUP SCREEN */
        #setup-screen {
            position: fixed; inset: 0; background: #111; z-index: 10000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            font-family: 'Inter', sans-serif; color: white; cursor: auto;
        }
        .input-group { margin: 15px; width: 80%; max-width: 400px; }
        .input-group input { 
            width: 100%; padding: 12px; background: #222; border: 1px solid #444;
            color: white; border-radius: 4px; font-size: 1.1rem; box-sizing: border-box; outline: none;
        }
        #start-btn { 
            padding: 12px 30px; background: var(--led); border: none; 
            border-radius: 4px; font-weight: bold; cursor: pointer; color: black; 
            font-size: 1rem; text-transform: uppercase; letter-spacing: 1px;
        }

        /* MAIN LAYOUT */
        #display-screen { 
            display: none; flex-direction: column; height: 100vh; width: 100vw; 
            box-sizing: border-box; padding: 0 2vw;
        }

        /* HEADER MIT UHR */
        .header-area { 
            flex: 0 0 auto; 
            padding: 2vh 0 1vh 0; 
            display: flex; 
            justify-content: space-between; 
            align-items: flex-end; /* Unten bündig */
            border-bottom: 2px solid var(--led-dim);
            margin-bottom: 0.5vh;
        }

        .station-name { 
            font-size: clamp(20px, 4.5vh, 50px); 
            color: var(--led); 
            margin: 0; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            max-width: 75%;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .header-clock {
            font-size: clamp(20px, 4.5vh, 50px);
            color: var(--led);
            font-variant-numeric: tabular-nums;
        }
        .blink-colon { animation: blink 1s steps(2, start) infinite; }

        .labels {
            display: grid; grid-template-columns: var(--col-line) 1fr var(--col-time);
            font-family: 'Inter', sans-serif; 
            font-size: clamp(10px, 2vh, 20px); 
            color: #888; text-transform: uppercase; 
            padding-bottom: 0.5vh; margin-top: 0.5vh;
            letter-spacing: 1px;
        }
        .labels span:last-child { text-align: right; }

        /* MATRIX */
        #matrix { flex: 1 1 auto; display: flex; flex-direction: column; overflow: hidden; }

        .row {
            flex: 1; display: grid; grid-template-columns: var(--col-line) 1fr var(--col-time);
            align-items: center; 
            border-bottom: 1px solid #1a1a1a;
            font-size: 5.5vh; min-height: 0; line-height: 1;
        }

        .line-cell { color: var(--led); white-space: nowrap; overflow: hidden; letter-spacing: 1px;}
        .dest-cell { overflow: hidden; white-space: nowrap; display: flex; position: relative; margin-right: 10px; color: var(--led); }
        .marquee-content { display: inline-block; will-change: transform; padding-right: 2em; }

        @keyframes marquee { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }
        .animate-scroll { animation: marquee 12s linear infinite; }

        .time-cell { 
            text-align: right; font-variant-numeric: tabular-nums; 
            display: flex; justify-content: flex-end; align-items: baseline; gap: 1vw;
            color: var(--led);
        }
        
        .delay-info { font-size: 0.5em; color: var(--led-alert); font-family: 'Inter', sans-serif; font-weight: bold; }
        .is-cancelled { text-decoration: line-through; color: var(--led-alert) !important; text-shadow: none; opacity: 0.7; }
        .is-cancelled .line-cell, .is-cancelled .dest-cell, .is-cancelled .time-cell { color: var(--led-alert); }

        .sofort { animation: blink 1s steps(2, start) infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        /* FULLSCREEN ICON (Hidden in production feel) */
        #fs-icon { 
            position: fixed; bottom: 10px; right: 10px; z-index: 20000; 
            color: #333; cursor: pointer; opacity: 0.3; padding: 10px;
        }
        #fs-icon:hover { opacity: 1; color: var(--led); }

    </style>
</head>
<body>

    <div id="setup-screen">
        <h2 style="margin-bottom: 20px; letter-spacing: 2px;">SYSTEM SETUP</h2>
        <div class="input-group"><input type="text" id="city-input" placeholder="Stadt (z.B. Hamburg)"></div>
        <div class="input-group"><input type="text" id="stop-input" placeholder="Haltestelle (z.B. Rathaus)"></div>
        <button id="start-btn">INITIALISIEREN</button>
    </div>

    <div id="display-screen">
        <div class="header-area">
            <div class="station-name" id="station-title">BOOTING...</div>
            <div class="header-clock" id="main-clock">00<span class="blink-colon">:</span>00</div>
        </div>
        <div class="labels"><span>Linie</span><span>Ziel</span><span>Abfahrt</span></div>
        <div id="matrix"></div>
    </div>
    
    <div id="fs-icon" onclick="toggleFullscreen()">[FS]</div>

<script>
    let stationID = null;
    let busData = [];
    let wakeLock = null;

    // --- FULLSCREEN ---
    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => console.log(err));
        } else {
            document.exitFullscreen();
        }
    }

    // --- SETUP LOGIC ---
    document.getElementById('start-btn').onclick = async () => {
        const city = document.getElementById('city-input').value;
        const stop = document.getElementById('stop-input').value;
        if(!city || !stop) return alert("Eingabe fehlt.");

        const btn = document.getElementById('start-btn');
        btn.innerText = "VERBINDE...";

        try {
            const res = await fetch(`https://v6.db.transport.rest/locations?query=${encodeURIComponent(city + " " + stop)}&results=1`);
            const data = await res.json();
            
            if(!data[0]) {
                btn.innerText = "INITIALISIEREN";
                return alert("Ort nicht gefunden.");
            }

            stationID = data[0].id;
            // Name etwas bereinigen (Ortsnamen entfernen für cleaner Look wenn möglich)
            let cleanName = data[0].name.replace(city + ", ", "").replace(city + " ", "");
            document.getElementById('station-title').innerText = cleanName;
            
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('display-screen').style.display = 'flex';

            // Wake Lock für Always On
            if ('wakeLock' in navigator) {
                try { await navigator.wakeLock.request('screen'); } catch (err) {}
            }

            // Start Animation ("Pixel Test")
            runBootSequence();
            
        } catch(e) { 
            btn.innerText = "FEHLER";
            setTimeout(() => btn.innerText = "INITIALISIEREN", 2000);
        }
    };

    function runBootSequence() {
        // Simuliert das Hochfahren einer Anzeige (Alle Pixel an)
        const matrix = document.getElementById('matrix');
        matrix.innerHTML = '<div style="display:flex; align-items:center; justify-content:center; height:100%; font-size:3vh; color:var(--led-dim);">SYSTEM TEST...</div>';
        
        setTimeout(() => {
            startEngine();
        }, 1500);
    }

    function startEngine() {
        updateData();
        setInterval(updateData, 30000);
        setInterval(tick, 1000); // 1 Sekunde Takt für Uhr und Logic
        window.addEventListener('resize', renderFrame);
    }

    // --- DATA LOGIC ---
    async function updateData() {
        if(!stationID) return;
        try {
            const res = await fetch(`https://v6.db.transport.rest/stops/${stationID}/departures?results=20&duration=60`);
            const data = await res.json();
            
            busData = data.departures.map(dep => {
                const uniqueId = dep.tripId || (dep.line.name + dep.direction + dep.plannedWhen);
                // Suche existierenden Bus um "SofortSince" zu behalten
                const existing = busData.find(b => b.tripId === uniqueId);
                
                const plannedTime = new Date(dep.plannedWhen).getTime();
                const realTime = dep.when ? new Date(dep.when).getTime() : plannedTime;
                const delayMin = Math.floor((realTime - plannedTime) / 60000);

                return {
                    tripId: uniqueId,
                    line: dep.line.name,
                    dest: dep.direction,
                    time: realTime,
                    delay: delayMin,
                    cancelled: dep.cancelled || false,
                    sofortSince: existing ? existing.sofortSince : null
                };
            });
            
            busData.sort((a, b) => a.time - b.time); // Sort by Time
            renderFrame();
        } catch(e) {}
    }

    // --- RENDER LOGIC ---
    function tick() {
        const now = new Date();
        
        // 1. Uhr Update
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const clockEl = document.getElementById('main-clock');
        // HTML neu setzen erzwingt Blink-Sync, aber wir machen es smoother:
        clockEl.innerHTML = `${hours}<span class="blink-colon">:</span>${minutes}`;

        // 2. Bus Logic (wegnehmen wenn zu alt)
        const nowTs = now.getTime();
        let needsRedraw = false;
        
        busData = busData.filter(bus => {
            const timeDiff = bus.time - nowTs;
            if (timeDiff <= 0) {
                if (!bus.sofortSince) bus.sofortSince = nowTs;
                // Zeige Bus noch 15 Sekunden an, während er "da" ist
                if ((nowTs - bus.sofortSince) > 15000) { 
                    needsRedraw = true; 
                    return false; 
                }
            }
            return true;
        });

        if(needsRedraw) renderFrame();
        
        // 3. Zeiten aktualisieren (Minuten runterzählen)
        updateTimeTexts(nowTs);
    }

    function renderFrame() {
        const container = document.getElementById('matrix');
        const headerArea = document.querySelector('.header-area');
        if(!container) return;

        // Platzberechnung
        const availableHeight = window.innerHeight - headerArea.offsetHeight - 40;
        const rowHeight = window.innerHeight * 0.12; 
        const maxRows = Math.max(1, Math.floor(availableHeight / rowHeight));

        const list = busData.slice(0, maxRows);
        const currentSignature = list.map(b => b.tripId + (b.cancelled?'c':'')).join('|');

        if (container.dataset.sig !== currentSignature) {
            container.dataset.sig = currentSignature;
            container.innerHTML = ''; 

            list.forEach(bus => {
                const row = document.createElement('div');
                row.className = 'row' + (bus.cancelled ? ' is-cancelled' : '');
                
                let delayStr = '';
                if(!bus.cancelled && bus.delay > 1) delayStr = `<span class="delay-info">+${bus.delay}</span>`;
                else if(!bus.cancelled && bus.delay < -1) delayStr = `<span class="delay-info">${bus.delay}</span>`;

                row.innerHTML = `
                    <div class="line-cell">${bus.line}</div>
                    <div class="dest-cell" id="c-${bus.tripId}"><span class="marquee-content" id="m-${bus.tripId}">${bus.dest}</span></div>
                    <div class="time-cell">
                        ${delayStr}
                        <span id="t-${bus.tripId}">--</span>
                    </div>
                `;
                container.appendChild(row);

                // Marquee Setup
                setTimeout(() => {
                    const m = document.getElementById(`m-${bus.tripId}`);
                    const c = document.getElementById(`c-${bus.tripId}`);
                    if (m && c && m.offsetWidth > c.offsetWidth) {
                        m.innerHTML = `${bus.dest} &nbsp;&nbsp;&nbsp;&nbsp; ${bus.dest} &nbsp;&nbsp;&nbsp;&nbsp;`;
                        m.classList.add('animate-scroll');
                    }
                }, 50);
            });
        }
        updateTimeTexts(Date.now());
    }

    function updateTimeTexts(nowTs) {
        busData.forEach(bus => {
            const el = document.getElementById(`t-${bus.tripId}`);
            if(!el) return;

            if (bus.cancelled) {
                el.innerText = "Entfällt";
                return;
            }

            const diffMin = Math.floor((bus.time - nowTs) / 60000);
            
            let val;
            if (bus.sofortSince || diffMin <= 0) {
                val = ''; // Leer lassen, damit "sofort" blinkt? Oder Text:
                // Bei echten Anzeigen oft leer und blinkt, oder einfach '0 min'
                el.innerHTML = '<span class="sofort">sofort</span>';
            } else if (diffMin > 60) {
                const d = new Date(bus.time);
                el.innerText = d.getHours() + ':' + String(d.getMinutes()).padStart(2, '0');
            } else {
                el.innerText = diffMin + " min";
            }
        });
    }
</script>
</body>
</html>
